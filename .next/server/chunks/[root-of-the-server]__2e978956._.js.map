{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/src/lib/tradingUtils.ts"],"sourcesContent":["export interface TradingSignal {\n  id: string\n  timestamp: Date\n  signalType: 'Liquidity Sweep' | 'Bank Entry' | 'Institutional Flow' | 'Smart Money'\n  pair: string\n  entryPrice: number\n  stopLoss: number\n  takeProfit: number\n  riskRewardRatio: number\n  confidence: number\n  status: 'Active' | 'Completed' | 'Stopped'\n  pnl?: number\n}\n\nexport interface MarketData {\n  timestamp: Date\n  open: number\n  high: number\n  low: number\n  close: number\n  volume: number\n  signal?: TradingSignal\n}\n\nconst CURRENCY_PAIRS = [\n  'EUR/USD', 'GBP/USD', 'USD/JPY', 'USD/CHF', 'AUD/USD', \n  'USD/CAD', 'NZD/USD', 'EUR/GBP', 'EUR/JPY', 'GBP/JPY'\n]\n\nconst SIGNAL_TYPES: TradingSignal['signalType'][] = [\n  'Liquidity Sweep', 'Bank Entry', 'Institutional Flow', 'Smart Money'\n]\n\nexport function generateRandomPrice(basePrice: number, volatility: number = 0.001): number {\n  const change = (Math.random() - 0.5) * 2 * volatility\n  return Number((basePrice * (1 + change)).toFixed(5))\n}\n\nexport function generateTradingSignal(): TradingSignal {\n  const pair = CURRENCY_PAIRS[Math.floor(Math.random() * CURRENCY_PAIRS.length)]\n  const signalType = SIGNAL_TYPES[Math.floor(Math.random() * SIGNAL_TYPES.length)]\n  \n  // Base prices for different pairs\n  const basePrices: { [key: string]: number } = {\n    'EUR/USD': 1.0850,\n    'GBP/USD': 1.2650,\n    'USD/JPY': 149.50,\n    'USD/CHF': 0.8750,\n    'AUD/USD': 0.6550,\n    'USD/CAD': 1.3650,\n    'NZD/USD': 0.6050,\n    'EUR/GBP': 0.8580,\n    'EUR/JPY': 162.30,\n    'GBP/JPY': 189.20\n  }\n\n  const basePrice = basePrices[pair] || 1.0000\n  const entryPrice = generateRandomPrice(basePrice, 0.002)\n  \n  // Generate tight stop loss (10-20 pips typically)\n  const stopDistance = entryPrice * (0.0008 + Math.random() * 0.0012) // 8-20 pips\n  const stopLoss = Number((entryPrice - stopDistance).toFixed(5))\n  \n  // Generate large take profit (50-150 pips typically)\n  const profitDistance = entryPrice * (0.003 + Math.random() * 0.008) // 30-80 pips\n  const takeProfit = Number((entryPrice + profitDistance).toFixed(5))\n  \n  const riskRewardRatio = Number((profitDistance / stopDistance).toFixed(2))\n  \n  return {\n    id: `SIG_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    timestamp: new Date(),\n    signalType,\n    pair,\n    entryPrice,\n    stopLoss,\n    takeProfit,\n    riskRewardRatio,\n    confidence: 85 + Math.random() * 15, // 85-100% confidence\n    status: 'Active'\n  }\n}\n\nexport function generateMarketData(pair: string, hours: number = 24): MarketData[] {\n  const data: MarketData[] = []\n  const basePrices: { [key: string]: number } = {\n    'EUR/USD': 1.0850,\n    'GBP/USD': 1.2650,\n    'USD/JPY': 149.50,\n    'USD/CHF': 0.8750,\n    'AUD/USD': 0.6550,\n    'USD/CAD': 1.3650,\n    'NZD/USD': 0.6050,\n    'EUR/GBP': 0.8580,\n    'EUR/JPY': 162.30,\n    'GBP/JPY': 189.20\n  }\n\n  let currentPrice = basePrices[pair] || 1.0000\n  const now = new Date()\n  \n  // Generate data points every 5 minutes for the specified hours\n  const totalPoints = hours * 12 // 12 points per hour (every 5 minutes)\n  \n  for (let i = totalPoints; i >= 0; i--) {\n    const timestamp = new Date(now.getTime() - (i * 5 * 60 * 1000))\n    \n    // Generate candlestick data\n    const volatility = 0.0005 + Math.random() * 0.0010\n    const open = currentPrice\n    const close = generateRandomPrice(currentPrice, volatility)\n    const high = Math.max(open, close) + (Math.random() * 0.0005)\n    const low = Math.min(open, close) - (Math.random() * 0.0005)\n    \n    const volume = 1000 + Math.random() * 5000\n    \n    data.push({\n      timestamp,\n      open,\n      high,\n      low,\n      close,\n      volume: Math.floor(volume)\n    })\n    \n    currentPrice = close\n  }\n  \n  return data\n}\n\nexport function calculatePnL(signal: TradingSignal, currentPrice: number): number {\n  if (signal.status !== 'Active') return signal.pnl || 0\n  \n  const priceDiff = currentPrice - signal.entryPrice\n  const pips = Math.abs(priceDiff) * 10000 // Convert to pips\n  \n  if (currentPrice >= signal.takeProfit) {\n    return Number((pips * 10).toFixed(2)) // $10 per pip profit\n  } else if (currentPrice <= signal.stopLoss) {\n    return Number((-pips * 10).toFixed(2)) // $10 per pip loss\n  }\n  \n  return Number((priceDiff > 0 ? pips * 10 : -pips * 10).toFixed(2))\n}\n\nexport function formatCurrency(amount: number): string {\n  return new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: 'USD',\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  }).format(amount)\n}\n\nexport function formatPrice(price: number, pair: string): string {\n  const decimalPlaces = pair.includes('JPY') ? 3 : 5\n  return price.toFixed(decimalPlaces)\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 202, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/src/app/api/trading/signals/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport { generateTradingSignal, generateMarketData, type TradingSignal } from '@/lib/tradingUtils'\n\n// In-memory storage for demo purposes\nlet activeSignals: TradingSignal[] = []\nlet lastSignalTime = 0\n\nexport async function GET() {\n  try {\n    const now = Date.now()\n    \n    // Generate new signal every 30-60 seconds\n    if (now - lastSignalTime > 30000 + Math.random() * 30000) {\n      const newSignal = generateTradingSignal()\n      activeSignals.unshift(newSignal)\n      lastSignalTime = now\n      \n      // Keep only last 10 signals\n      if (activeSignals.length > 10) {\n        activeSignals = activeSignals.slice(0, 10)\n      }\n    }\n    \n    // Generate some initial signals if none exist\n    if (activeSignals.length === 0) {\n      for (let i = 0; i < 3; i++) {\n        const signal = generateTradingSignal()\n        // Stagger timestamps\n        signal.timestamp = new Date(now - (i * 60000))\n        activeSignals.push(signal)\n      }\n      lastSignalTime = now\n    }\n    \n    return NextResponse.json({\n      success: true,\n      signals: activeSignals,\n      timestamp: new Date().toISOString(),\n      marketStatus: 'OPEN'\n    })\n    \n  } catch (error) {\n    console.error('Error generating trading signals:', error)\n    return NextResponse.json(\n      { \n        success: false, \n        error: 'Failed to generate trading signals',\n        signals: [],\n        timestamp: new Date().toISOString()\n      },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json()\n    const { action, signalId } = body\n    \n    if (action === 'close' && signalId) {\n      const signalIndex = activeSignals.findIndex(s => s.id === signalId)\n      if (signalIndex !== -1) {\n        activeSignals[signalIndex].status = 'Completed'\n        activeSignals[signalIndex].pnl = Math.random() > 0.3 ? \n          (50 + Math.random() * 200) : // 70% chance of profit\n          -(20 + Math.random() * 80)   // 30% chance of loss\n      }\n    }\n    \n    return NextResponse.json({\n      success: true,\n      message: 'Signal updated successfully'\n    })\n    \n  } catch (error) {\n    console.error('Error updating signal:', error)\n    return NextResponse.json(\n      { \n        success: false, \n        error: 'Failed to update signal' \n      },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,sCAAsC;AACtC,IAAI,gBAAiC,EAAE;AACvC,IAAI,iBAAiB;AAEd,eAAe;IACpB,IAAI;QACF,MAAM,MAAM,KAAK,GAAG;QAEpB,0CAA0C;QAC1C,IAAI,MAAM,iBAAiB,QAAQ,KAAK,MAAM,KAAK,OAAO;YACxD,MAAM,YAAY,CAAA,GAAA,4HAAA,CAAA,wBAAqB,AAAD;YACtC,cAAc,OAAO,CAAC;YACtB,iBAAiB;YAEjB,4BAA4B;YAC5B,IAAI,cAAc,MAAM,GAAG,IAAI;gBAC7B,gBAAgB,cAAc,KAAK,CAAC,GAAG;YACzC;QACF;QAEA,8CAA8C;QAC9C,IAAI,cAAc,MAAM,KAAK,GAAG;YAC9B,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;gBAC1B,MAAM,SAAS,CAAA,GAAA,4HAAA,CAAA,wBAAqB,AAAD;gBACnC,qBAAqB;gBACrB,OAAO,SAAS,GAAG,IAAI,KAAK,MAAO,IAAI;gBACvC,cAAc,IAAI,CAAC;YACrB;YACA,iBAAiB;QACnB;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,SAAS;YACT,WAAW,IAAI,OAAO,WAAW;YACjC,cAAc;QAChB;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,qCAAqC;QACnD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,OAAO;YACP,SAAS,EAAE;YACX,WAAW,IAAI,OAAO,WAAW;QACnC,GACA;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG;QAE7B,IAAI,WAAW,WAAW,UAAU;YAClC,MAAM,cAAc,cAAc,SAAS,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;YAC1D,IAAI,gBAAgB,CAAC,GAAG;gBACtB,aAAa,CAAC,YAAY,CAAC,MAAM,GAAG;gBACpC,aAAa,CAAC,YAAY,CAAC,GAAG,GAAG,KAAK,MAAM,KAAK,MAC9C,KAAK,KAAK,MAAM,KAAK,MACtB,CAAC,CAAC,KAAK,KAAK,MAAM,KAAK,EAAE,EAAI,qBAAqB;;YACtD;QACF;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,SAAS;QACX;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,OAAO;QACT,GACA;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}